<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Hyperscribe</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        body {
            margin: 0;
            height: 100vh;
            background: radial-gradient(circle at 40% 40%, rgba(255, 240, 250, 0.9), rgba(180, 200, 255, 0.85), rgba(160, 190, 255, 0.75)),
                        radial-gradient(circle at 70% 70%, rgba(255, 245, 250, 0.9), rgba(190, 220, 255, 0.85), rgba(170, 210, 255, 0.75)),
                        linear-gradient(120deg, rgba(220, 240, 255, 0.9), rgba(0, 40, 255, 0.7));
            background-blend-mode: soft-light, overlay, normal;
            overflow: hidden; /* Prevent any scrolling on the main body */
        }

        .logo {
            width: 150px;
            height: auto;
        }

        .button-container {
            margin-top: 20px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .toggle-button {
            width: 80px;
            height: 80px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            background-color: black;
            border: 5px solid transparent; /* Ensure space for border */
            border-radius: 50%; /* Makes it perfectly circular */
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toggle-button.active {
            border-color: red;
        }

        .toggle-button.paused {
            background-color: #666;
        }

        .toggle-button.medium {
            width: 72px;
            height: 72px;
            font-size: 16px;
        }

        .toggle-button.small {
            width: 64px;
            height: 64px;
            font-size: 14px;
        }

        .toggle-button:disabled {
            cursor: not-allowed;
        }

        .pause-button {
            width: 64px;
            height: 64px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            background-color: #666;
            border: 5px solid transparent;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pause-button:disabled {
            background-color: #ccc;
            color: #888;
            cursor: not-allowed;
        }

        .pause-button:not(:disabled) {
            background-color: #333;
        }

        .pause-button.large {
            width: 80px;
            height: 80px;
            font-size: 18px;
        }

        .pause-button.resume {
            border-color: green;
        }

        .pause-button.small {
            width: 64px;
            height: 64px;
            font-size: 14px;
        }

        .debug-message {
            margin-top: 10px;
            margin-bottom: 10px;
            color: darkgreen;
            font-family: "Helvetica", "Arial", "sans-serif";
        }

        /* Tab styles */
        .tabs {
            display: flex;
            margin-top: 20px;
            width: 80%;
            border-bottom: 2px solid rgba(0, 40, 255, 0.3);
        }

        .duration-display {
            font-family: "Helvetica", "Arial", "sans-serif";
            font-size: 12px;
            font-weight: normal;
            color: #333;
            padding: 5px 10px;
            border-radius: 3px;
        }

        .tab {
            background-color: rgba(220, 240, 255, 0.5);
            border: none;
            padding: 10px;
            cursor: pointer;
            font-family: "Helvetica", "Arial", "sans-serif";
            font-size: 14px;
            font-weight: bold;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
            margin-right: 2px;
            transition: background-color 0.3s ease;
        }

        .tab.active {
            background-color: rgba(0, 40, 255, 0.2);
            color: #333;
        }

        .tab:hover {
            background-color: rgba(0, 40, 255, 0.15);
        }

        /* Styles for table container with permanent scrollbar */
        .table-container {
            height: calc(100vh - 280px); /* Adjusted height for tabs */
            overflow-y: scroll; /* Always show scrollbar */
            width: 80%;
            display: none; /* Hidden by default, shown by tabs */
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 40, 255, 0.5) rgba(220, 240, 255, 0.3);
        }

        .table-container.active {
            display: block;
        }

        /* Legend styles */
        .legend {
            width: 80%;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            font-family: "Helvetica", "Arial", "sans-serif";
            font-size: 12px;
        }

        /* Filter controls styles */
        .filter-controls {
            width: 100%;
            padding: 0;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            font-family: "Helvetica", "Arial", "sans-serif";
            font-size: 12px;
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: flex-end;
        }

        /* Feedback styles */
        .feedback-content {
            padding: 20px;
            font-family: "Helvetica", "Arial", "sans-serif";
        }


        #feedback-textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 2px solid rgba(0, 40, 255, 0.3);
            border-radius: 5px;
            font-family: "Helvetica", "Arial", "sans-serif";
            font-size: 14px;
            resize: vertical;
            box-sizing: border-box;
            background-color: rgba(255, 255, 255, 0.9);
        }

        #feedback-textarea:focus {
            outline: none;
            border-color: rgba(0, 40, 255, 0.6);
        }

        .feedback-submit-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }

        #feedback-submit-button {
            padding: 10px 20px;
            background-color: rgba(0, 40, 255, 0.8);
            color: white;
            border: none;
            border-radius: 5px;
            font-family: "Helvetica", "Arial", "sans-serif";
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #feedback-submit-button:hover {
            background-color: rgba(0, 40, 255, 1);
        }

        #feedback-submit-button:disabled {
            background-color: rgba(0, 40, 255, 0.4);
            cursor: not-allowed;
        }

        #feedback-message {
            font-family: "Helvetica", "Arial", "sans-serif";
            font-size: 14px;
            font-weight: normal;
        }

        #feedback-message.success {
            color: #28a745;
        }

        #feedback-message.error {
            color: #dc3545;
        }

        .filter-controls label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-weight: normal;
            font-size: 11px;
            color: #333;
        }


        .legend-item {
            display: inline-block;
            margin-right: 5px;
            padding: 3px 8px;
            border-radius: 3px;
            color: black;
            font-weight: normal;
        }

        /* Custom scrollbar styles */
        .table-container::-webkit-scrollbar {
            width: 8px;
        }

        .table-container::-webkit-scrollbar-track {
            background: rgba(220, 240, 255, 0.3);
            border-radius: 4px;
        }

        .table-container::-webkit-scrollbar-thumb {
            background-color: rgba(0, 40, 255, 0.5);
            border-radius: 4px;
        }

        /* Table styling */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 0 auto;
            table-layout: fixed; /* For consistent column widths */
        }

        /* Ensure content-based row heights */
        table tr {
            height: auto !important; /* Override any fixed heights */
        }

        th {
            background-color: rgba(0, 40, 255, 0.2);
            color: #333;
            padding: 10px;
            text-align: center;
            font-family: "Helvetica", "Arial", "sans-serif";
        }

        tr {
            line-height: 1.3; /* Slightly increased for better readability with wrapping */
        }

        td {
            padding: 6px 8px;
            border-bottom: 1px solid rgba(0, 40, 255, 0.1);
            font-family: "Helvetica", "Arial", "sans-serif";
            font-size: 11px;
            vertical-align: top; /* Align content to top */
            overflow: visible;
            word-wrap: break-word;
            box-sizing: border-box;
            height: min-content; /* Use only what's needed */
            text-align: right;
        }

        /* First column can wrap */
        td:first-child {
            white-space: normal;
            text-align: left;
        }

        /* Activity table second column (message column) should be left-aligned */
        #activity-table-body td:nth-child(2) {
            text-align: left;
        }

        #error {
            color: red;
            margin-top: 10px;
            font-family: "Helvetica", "Arial", "sans-serif";
        }

        .header-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
        }

        .note-reference {
            font-family: "Helvetica", "Arial", "sans-serif";
            font-size: 14px;
            font-weight: bold;
            color: #333;
        }

        /* Center content vertically and horizontally */
        .app-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100vh;
            padding-top: 5px;
            box-sizing: border-box; /* Include padding in height calculation */
            position: relative; /* For proper positioning of child elements */
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header-container">
            <img src="https://images.prismic.io/canvas-website/Z8VfRhsAHJWomCr3_hyperscribe_logo.png?auto=format,compress" alt="Logo" class="logo">
            <div class="note-reference">({{noteReference}})</div>
        </div>
        <div class="button-container">
            <button
                class="toggle-button"
                id="captureButton"
                data-interval="{{interval}}">
                Start
            </button>
            <button
                class="pause-button"
                id="pauseButton"
                disabled
                onclick="togglePause()">
                Pause
            </button>
        </div>


        <div id="debugMessage" class="debug-message"></div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('activity', this)">Activity</button>
            <button class="tab" onclick="switchTab('transcript', this)">Transcript</button>
            <button class="tab" onclick="switchTab('logs', this)">Logs</button>
            <button class="tab" onclick="switchTab('feedback', this)">Feedback</button>
        </div>

        <div id="activity-container" class="table-container active">
            <div class="filter-controls">
                <span id="duration" class="duration-display"></span>
            </div>
            <table>
                <colgroup>
                    <col style="width: 40px">
                    <col style="width: calc(70% - 40px)">
                    <col style="width: 30%;text-align: right;">
                </colgroup>
                <tbody id="activity-table-body">
                </tbody>
            </table>
        </div>

        <div id="logs-container" class="table-container">
            <div class="filter-controls">
                <span id="duration-logs" class="duration-display"></span>
            </div>
            <table>
                <colgroup>
                    <col style="width: 70%">
                    <col style="width: 30%;text-align: right;">
                </colgroup>
                <tbody id="logs-table-body">
                </tbody>
            </table>
        </div>

        <div id="transcript-container" class="table-container">
            <div id="transcript-legend" class="legend" style="display: none;">
                <div id="legend-content"></div>
            </div>
            <table>
                <colgroup>
                    <col style="width: 100%">
                </colgroup>
                <tbody id="transcript-table-body">
                </tbody>
            </table>
        </div>

        <div id="feedback-container" class="table-container">
            <div class="feedback-content">
                <textarea id="feedback-textarea" placeholder="Please share your feedback..."></textarea>
                <div class="feedback-submit-row">
                    <button id="feedback-submit-button" onclick="submitFeedback()">Submit</button>
                    <span id="feedback-message"></span>
                </div>
            </div>
        </div>

        <div id="error"></div>
    </div>

    <script>
        // Constants
        const CONSTANTS = {
            REFRESH_INTERVALS: {
                LOG: 1.7 * 1000,
                CELL: 2.3 * 1000,
                TURN_PROCESSING: 450
            },
            AUDIO: {
                MIME_TYPE: "audio/webm"
            },
            SPEAKER_COLORS: [
                '#FFE6CC', '#E6FFE6', '#FFF0E6', '#F0E6FF', '#FFE6F0',
                '#E6FFFF', '#E6F3FF', '#F5FFE6', '#FFE6E6', '#E6E6FF'
            ]
        };

        // Application state
        const appState = {
            recording: {
                active: false,
                paused: {{isPaused|yesno:"true,false"}},
                ended: {{isEnded|yesno:"true,false"}},
                recorder: null,
                intervalId: null,
                chunkId: {{chunkId}}
            },
            progress: {
                started: false,
                previousMessage: new Date(0),
                webSocket: null
            },
            transcript: {
                displayedTimes: new Set(),
                speakerColors: new Map(),
                colorIndex: 0,
                pendingTurns: [],
                processingTurns: false
            },
            activeTab: 'activity'
        };

        // Audio Recording Class
        class AudioRecorder {
            constructor(patientId, noteId, interval) {
                this.patientId = patientId;
                this.noteId = noteId;
                this.interval = interval;
                this.stream = null;
            }

            async setup() {
                this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                if (!MediaRecorder.isTypeSupported(CONSTANTS.AUDIO.MIME_TYPE)) {
                    throw new Error(`MIME type ${CONSTANTS.AUDIO.MIME_TYPE} is not supported.`);
                }

                const recorder = new MediaRecorder(this.stream, { mimeType: CONSTANTS.AUDIO.MIME_TYPE });
                recorder.ondataavailable = this.handleDataAvailable.bind(this);
                return recorder;
            }

            handleDataAvailable(event) {
                if (event.data.size > 0) {
                    const audioBlob = new Blob([event.data], { type: CONSTANTS.AUDIO.MIME_TYPE });
                    const formData = new FormData();
                    appState.recording.chunkId += 1;
                    const chunkIndex = String(appState.recording.chunkId).padStart(3, '0');
                    formData.append("audio", audioBlob, `chunk_${chunkIndex}_${this.patientId}_${this.noteId}.webm`);

                    fetch('{{saveAudioURL | safe}}', {
                        method: "POST",
                        body: formData,
                    })
                    .then(response => response.text())
                    .then(result => console.log(result))
                    .catch(error => console.error('Error uploading audio:', error));
                }
            }

            start() {
                if (appState.recording.recorder) {
                    appState.recording.recorder.start();
                    appState.recording.intervalId = setInterval(() => {
                        appState.recording.recorder.requestData();
                    }, 1000 * this.interval);
                }
            }

            stop() {
                if (appState.recording.recorder) {
                    appState.recording.recorder.stop();
                    if (appState.recording.intervalId) {
                        clearInterval(appState.recording.intervalId);
                        appState.recording.intervalId = null;
                    }
                }

                // Stop all tracks to release microphone access
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
            }
        }

        // Event routing utilities
        const eventRouter = {
            routeEvent(section, message, elapsedTime) {
                if (!section.startsWith('events:')) return;
                
                const maskStr = section.split(':')[1];
                if (!maskStr || isNaN(parseInt(maskStr))) return;
                
                const mask = parseInt(maskStr);
                const medicalValue1 = 1;    // events:1
                const medicalValue2 = 2;    // events:2
                const technicalValue = 4;  // events:4
                
                const isMedical = (mask & medicalValue1) !== 0 || (mask & medicalValue2) !== 0;
                const isTechnical = (mask & technicalValue) !== 0;
                
                if (isMedical) {
                    this.addToActivity(message, elapsedTime, section);
                }
                if (isTechnical) {
                    this.addToLogs(message, elapsedTime, section);
                }
            },
            
            addToActivity(message, elapsedTime, section) {
                const tbody = document.getElementById('activity-table-body');

                // Remove "waiting..." row if it exists
                if (tbody.innerHTML.includes('waiting...')) {
                    tbody.innerHTML = '';
                }

                // Determine icon based on section
                const mask = parseInt(section.split(':')[1] || '0');
                const technicalValue = 4;  // events:4
                const isTechnical = (mask & technicalValue) !== 0;

                let iconName = 'radio_button_checked';
                // Only show icon if message is NOT also displayed in Logs
                if (!isTechnical) {
                    if ((mask & 1) !== 0) {  // events:1
                        iconName = 'new_label';  // Material icon for "New Label"
                    } else if ((mask & 2) !== 0) {  // events:2
                        iconName = 'label';  // Material icon for "Label"
                    }
                }

                const row = ui.createTableRowWithIcon(iconName, message, elapsedTime);
                row.dataset.section = section;
                tbody.insertBefore(row, tbody.firstChild);
            },
            
            addToLogs(message, elapsedTime, section) {
                const tbody = document.getElementById('logs-table-body');

                // Remove "waiting..." row if it exists
                if (tbody.innerHTML.includes('waiting...')) {
                    tbody.innerHTML = '';
                }

                const row = ui.createTableRow([message, elapsedTime]);
                row.dataset.section = section;
                tbody.insertBefore(row, tbody.firstChild);
            }
        };

        // UI Utilities
        const ui = {
            switchTab(tabName, clickedElement) {
                document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.table-container').forEach(container => container.classList.remove('active'));
                if (clickedElement) {
                    clickedElement.classList.add('active');
                } else {
                    // Fallback: find the tab by its onclick attribute
                    document.querySelectorAll('.tab').forEach(tab => {
                        if (tab.getAttribute('onclick') && tab.getAttribute('onclick').includes(`'${tabName}'`)) {
                            tab.classList.add('active');
                        }
                    });
                }
                document.getElementById(tabName + '-container').classList.add('active');
                appState.activeTab = tabName;
            },

            updateButton(buttonId, text, classes = [], disabled = false) {
                const btn = document.getElementById(buttonId);
                btn.textContent = text;
                btn.disabled = disabled || appState.recording.ended;
                btn.className = buttonId === 'captureButton' ? 'toggle-button' : 'pause-button';
                classes.forEach(cls => btn.classList.add(cls));
            },

            setButtonState(state) {
                const states = {
                    inactive: {
                        capture: { text: "Start", classes: [], disabled: false },
                        pause: { text: "Pause", classes: [], disabled: true }
                    },
                    active: {
                        capture: { text: "Stop", classes: ["active", "medium"], disabled: false },
                        pause: { text: "Pause", classes: ["small"], disabled: false }
                    },
                    paused: {
                        capture: { text: "Stop", classes: ["small", "paused", "active"], disabled: true },
                        pause: { text: "Resume", classes: ["large", "resume"], disabled: false }
                    },
                    ended: {
                        capture: { text: "Start", classes: [], disabled: true },
                        pause: { text: "Pause", classes: [], disabled: true }
                    }
                };
                
                const config = states[state];
                this.updateButton('captureButton', config.capture.text, config.capture.classes, config.capture.disabled);
                this.updateButton('pauseButton', config.pause.text, config.pause.classes, config.pause.disabled);
            },

            createTableRow(cellContents) {
                const row = document.createElement('tr');
                cellContents.forEach(content => {
                    const cell = document.createElement('td');
                    cell.textContent = content;
                    row.appendChild(cell);
                });
                return row;
            },

            createTableRowWithIcon(iconName, message, elapsedTime) {
                const row = document.createElement('tr');
                
                // Icon cell
                const iconCell = document.createElement('td');
                iconCell.style.textAlign = 'center';
                iconCell.style.paddingLeft = '8px';
                iconCell.style.paddingRight = '8px';
                if (iconName) {
                    const icon = document.createElement('i');
                    icon.className = 'material-icons';
                    icon.textContent = iconName;
                    icon.style.fontSize = '16px';
                    icon.style.color = '#666';
                    iconCell.appendChild(icon);
                }
                row.appendChild(iconCell);
                
                // Message cell
                const messageCell = document.createElement('td');
                messageCell.textContent = message;
                row.appendChild(messageCell);
                
                // Time cell
                const timeCell = document.createElement('td');
                timeCell.textContent = elapsedTime;
                row.appendChild(timeCell);
                
                return row;
            },

            updateLegend(speakerColors) {
                const legend = document.getElementById('transcript-legend');
                const legendContent = document.getElementById('legend-content');
                
                if (speakerColors.size > 0) {
                    legend.style.display = 'block';
                    legendContent.innerHTML = '';
                    speakerColors.forEach((color, speaker) => {
                        const legendItem = document.createElement('span');
                        legendItem.className = 'legend-item';
                        legendItem.style.backgroundColor = color;
                        legendItem.textContent = speaker;
                        legendContent.appendChild(legendItem);
                    });
                }
            }
        };

        // Interval Management
        const intervalManager = {
            intervals: new Map(),
            
            start(name, callback, delay) {
                this.stop(name);
                this.intervals.set(name, setInterval(callback, delay));
            },
            
            stop(name) {
                const intervalId = this.intervals.get(name);
                if (intervalId) {
                    clearInterval(intervalId);
                    this.intervals.delete(name);
                }
            },
            
            stopAll() {
                this.intervals.forEach((_, name) => this.stop(name));
                if (appState.progress.webSocket) {
                    appState.progress.webSocket.close();
                    appState.progress.webSocket = null;
                }
            },
            
            startProgressConnection() {
                this.start('cellRefresh', updateTimeCells, CONSTANTS.REFRESH_INTERVALS.CELL);
                connectProgressWebSocket();
            }
        };

        // Global functions for backward compatibility
        function switchTab(tabName, clickedElement) {
            ui.switchTab(tabName, clickedElement);
        }

        function setButtonState(state) {
            ui.setButtonState(state);
        }


        async function togglePause() {
            if (!appState.recording.paused) {
                // Pause recording
                appState.recording.paused = true;
                ui.setButtonState('paused');

                // Stop the MediaRecorder using AudioRecorder
                if (appState.recording.recorder) {
                    audioRecorder.stop();
                    console.log("Recording paused");
                }

                // Fetch pause session URL
                fetch('{{pauseSessionURL | safe}}', {method: "POST"})
                .then(response => response.text())
                .then(result => console.log(result))
                .catch(error => console.error('Error pausing session:', error));
            } else {
                // Resume recording
                appState.recording.paused = false;
                ui.setButtonState('active');

                // Re-initialize AudioRecorder (needed because MediaStream was stopped during pause)
                const recordingInterval = parseInt(document.getElementById("captureButton").dataset.interval);
                audioRecorder = new AudioRecorder('{{patientUuid}}', '{{noteUuid}}', recordingInterval);

                try {
                    appState.recording.recorder = await audioRecorder.setup();
                    audioRecorder.start();
                    console.log("Recording resumed");
                } catch (error) {
                    console.error("Error resuming recording:", error);
                    return;
                }
                
                // Start progress and render fetches if not already running
                startProgressAndRenderFetches();
                
                // Fetch resume session URL
                fetch('{{resumeSessionURL | safe}}', {method: "POST"})
                .then(response => response.text())
                .then(result => console.log(result))
                .catch(error => console.error('Error resuming session:', error));
            }
        }

        let audioRecorder = null;

        const button = document.getElementById("captureButton");
        button.addEventListener("click", async () => {
            if (!appState.recording.active) {
                // Start recording
                appState.recording.active = true;
                appState.recording.paused = false;
                ui.setButtonState('active');

                resetTable();
                resetTranscriptTable();
                startProgressAndRenderFetches();
                
                // Initialize AudioRecorder
                const recordingInterval = parseInt(document.getElementById("captureButton").dataset.interval);
                audioRecorder = new AudioRecorder('{{patientUuid}}', '{{noteUuid}}', recordingInterval);
                
                try {
                    appState.recording.recorder = await audioRecorder.setup();
                    
                    // Start new session
                    fetch('{{newSessionURL | safe}}', {method: "POST"})
                    .then(response => response.text())
                    .then(result => {
                        console.log(result);
                        audioRecorder.start();
                        console.log("Recording started");
                    })
                    .catch(error => console.error('Error creating session:', error));
                } catch (error) {
                    console.error("Error setting up recording:", error);
                }
            } else {
                // Stop recording
                appState.recording.active = false;
                appState.recording.paused = false;
                appState.recording.ended = true;
                ui.setButtonState('ended');

                if (audioRecorder) {
                    audioRecorder.stop();
                }

                // Fetch end session URL
                fetch('{{endSessionURL | safe}}', {method: "POST"})
                .then(response => response.text())
                .then(result => console.log(result))
                .catch(error => console.error('Error ending session:', error));
            }
        });

        function resetTranscriptTable() {
            const tbody = document.getElementById('transcript-table-body');
            tbody.innerHTML = '<tr><td>waiting...</td></tr>';
            const legend = document.getElementById('transcript-legend');
            legend.style.display = 'none';
            document.getElementById('legend-content').innerHTML = '';

            // Clear tracking variables using appState
            appState.transcript.displayedTimes.clear();
            appState.transcript.speakerColors.clear();
            appState.transcript.colorIndex = 0;
            appState.transcript.pendingTurns = [];
            appState.transcript.processingTurns = false;
        }

        function initializeButtonStates() {
            if (appState.recording.ended) {
                // Initialize as ended state
                appState.recording.active = false;
                appState.recording.paused = false;
                ui.setButtonState('ended');
            } else if (appState.recording.paused) {
                // Initialize as paused state
                appState.recording.active = true;
                ui.setButtonState('paused');
                // Initialize previousMessage for paused state
                appState.progress.previousMessage = new Date();
                // Start fetches since we're in a paused (active) session
                startProgressAndRenderFetches();
            } else {
                // Initialize as normal state
                appState.recording.active = false;
                appState.recording.paused = false;
                ui.setButtonState('inactive');
            }
        }

        function startProgressAndRenderFetches() {
            if (!appState.progress.started) {
                // Start progress WebSocket connection
                intervalManager.startProgressConnection();
                appState.progress.started = true;
            } else {
                // If already started, just ensure cell refresh interval is running
                intervalManager.start('cellRefresh', updateTimeCells, CONSTANTS.REFRESH_INTERVALS.CELL);
            }
        }
        

        document.addEventListener('DOMContentLoaded', function () {
            resetTable();
            resetTranscriptTable();
            initializeButtonStates();
            
            // Initialize previousMessage to epoch to allow initial content display
            appState.progress.previousMessage = new Date(0);
            
            // Fetch initial progress data, then connect to WebSocket
            fetchInitialProgressData();
        });

        // -----------------------------------------------------------------
        // PROGRESS --------------------------------------------------------
        // -----------------------------------------------------------------

        function updateTimeCells() {
        const duration = document.getElementById('duration');
        const durationLogs = document.getElementById('duration-logs');
        // eslint-disable-next-line no-prototype-builtins
        if (duration.hasOwnProperty('startingTime')) {
            const now = new Date();
            const elapsedSeconds = (now.getTime() - duration.startingTime) / 1000;
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = Math.floor(elapsedSeconds % 60);
            const timeText = `${minutes}m ${String(seconds).padStart(2, '0')}s`;
            duration.textContent = timeText;
            durationLogs.textContent = timeText;
        }
        }

        function resetTable() {
            document.getElementById('activity-table-body').innerHTML = '<tr><td colspan="3">waiting...</td></tr>';
            document.getElementById('logs-table-body').innerHTML = '<tr><td colspan="2">waiting...</td></tr>';
        }

        function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
            }
        }
        console.log({'cookieName': name, 'cookieValue': cookieValue});
        return cookieValue;
        }

        async function fetchInitialProgressData() {
            const progressURL = '{{progressURL | safe}}';
            const messageEndFlag = '{{endFlag}}';
            
            try {
                console.log('Fetching initial progress data...');
                const response = await fetch(progressURL, { cache: 'no-store' });
                if (response.ok) {
                    const data = await response.json();
                    displayProgress(data, messageEndFlag);
                    console.log('Initial progress data loaded');
                } else {
                    console.warn('Failed to fetch initial progress data:', response.status);
                }
            } catch (error) {
                console.error('Error fetching initial progress data:', error);
            }
            
            
            // After fetching initial data, connect to WebSocket for live updates
            console.log('Connecting to WebSocket...');
            connectProgressWebSocket();
        }

        function connectProgressWebSocket() {
            const wsProgressURL = '{{wsProgressURL | safe}}';
            const messageEndFlag = '{{endFlag}}';
            
            if (appState.progress.webSocket) {
                appState.progress.webSocket.close();
            }
            
            try {
                appState.progress.webSocket = new WebSocket(wsProgressURL);
                
                appState.progress.webSocket.onopen = function(event) {
                    console.log('Progress WebSocket connected');
                };
                
                appState.progress.webSocket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        // Handle nested message structure with events array from WebSocket
                        if (data.message && Array.isArray(data.message.events)) {
                            data.message.events.forEach(message => {
                                handleWebSocketMessage(message, messageEndFlag);
                            });
                        }
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                    }
                };
                
                appState.progress.webSocket.onerror = function(error) {
                    console.error('WebSocket error:', error);
                };
                
                appState.progress.webSocket.onclose = function(event) {
                    console.log('Progress WebSocket closed:', event.code, event.reason);
                    // Attempt to reconnect after 3 seconds if not a clean close
                    if (event.code !== 1000 && appState.progress.started) {
                        setTimeout(() => {
                            console.log('Attempting to reconnect WebSocket...');
                            connectProgressWebSocket();
                        }, 3000);
                    }
                };
            } catch (error) {
                console.error('Error creating WebSocket connection:', error);
            }
        }

        function handleWebSocketMessage(message, endOfMessage) {
            if (!message) return;
            
            const currentMessage = new Date(message.time);
            
            // Update previousMessage to track the latest timestamp, but don't filter based on it for WebSocket
            if (currentMessage.getTime() > appState.progress.previousMessage.getTime()) {
                appState.progress.previousMessage = currentMessage;
            }
            
            // Handle events section (Progress tab)
            if (message.section.startsWith('events:')) {
                addEventMessage(message, endOfMessage);
            }
            
            // Handle transcript section (Transcript tab)
            if (message.section === 'transcript') {
                addTranscriptMessage(message, endOfMessage);
            }
        }
        
        function addEventMessage(message, endOfMessage) {
            // End of messages check
            if (message.message === endOfMessage) {
                intervalManager.stopAll();
                appState.progress.started = false;
                const duration = document.getElementById('duration');
                const durationLogs = document.getElementById('duration-logs');
                duration.textContent = '';
                durationLogs.textContent = '';
                return;
            }
            
            // Get or set starting time for duration calculation
            const duration = document.getElementById('duration');
            const messageTime = new Date(message.time);
            
            if (!duration.hasOwnProperty('startingTime')) {
                duration.startingTime = messageTime;
                const durationLogs = document.getElementById('duration-logs');
                durationLogs.startingTime = messageTime;
            }
            
            // Calculate elapsed time
            const elapsedSeconds = Math.floor((messageTime - duration.startingTime) / 1000);
            const timeText = elapsedSeconds > 0 ? `${elapsedSeconds}s` : duration.startingTime.toLocaleTimeString();
            
            // Route message to appropriate tab
            eventRouter.routeEvent(message.section, message.message, timeText);
        }
        
        function addTranscriptMessage(message, endOfMessage) {
            // End of messages check
            if (message.message === endOfMessage) {
                intervalManager.stopAll();
                appState.progress.started = false;
                return;
            }
            
            const colors = CONSTANTS.SPEAKER_COLORS;
            
            try {
                const discussionTurnArray = JSON.parse(message.message);
                if (Array.isArray(discussionTurnArray)) {
                    discussionTurnArray.forEach(discussionTurn => {
                        // Assign color to new speakers
                        if (!appState.transcript.speakerColors.has(discussionTurn.speaker)) {
                            appState.transcript.speakerColors.set(discussionTurn.speaker, colors[appState.transcript.colorIndex % colors.length]);
                            appState.transcript.colorIndex++;
                        }
                        
                        appState.transcript.pendingTurns.push({
                            speaker: discussionTurn.speaker,
                            text: discussionTurn.text,
                            messageTime: message.time
                        });
                    });
                    
                    // Update legend using utility
                    ui.updateLegend(appState.transcript.speakerColors);
                    
                    // Start processing turns if not already processing
                    if (!appState.transcript.processingTurns && appState.transcript.pendingTurns.length > 0) {
                        processTurnQueue();
                    }
                }
            } catch (e) {
                console.warn('Failed to parse discussion turn:', message.message);
            }
        }

        function displayProgress(data, endOfMessage) {
            const activityTbody = document.getElementById('activity-table-body');
            const logsTbody = document.getElementById('logs-table-body');
            const transcriptTbody = document.getElementById('transcript-table-body');
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = '';

            try {
                const currentMessage = new Date(data.time);
                if (
                    currentMessage.getTime() > appState.progress.previousMessage.getTime() &&
                    Array.isArray(data.messages) &&
                    data.messages.length > 0
                ) {
                        appState.progress.previousMessage = currentMessage;

                        // Separate messages by section
                        const eventMessages = data.messages.filter(msg => msg.section.startsWith('events:'));
                        const transcriptMessages = data.messages.filter(msg => msg.section === 'transcript');

                        // Handle events section (Activity and Logs tabs)
                        if (eventMessages.length > 0) {
                            activityTbody.innerHTML = '';
                            logsTbody.innerHTML = '';
                            
                            // compute the oldest time for events
                            const eventTimes = eventMessages.map(message => new Date(message.time));
                            const startingTime = new Date(Math.min(...eventTimes));
                            // set the duration object
                            const duration = document.getElementById('duration');
                            // eslint-disable-next-line no-prototype-builtins
                            if (duration.hasOwnProperty('startingTime') === false) {
                                duration.startingTime = startingTime;
                                const durationLogs = document.getElementById('duration-logs');
                                durationLogs.startingTime = startingTime;
                            }

                            // Sort event messages by time in reverse order (newest first)
                            const sortedEventMessages = eventMessages.sort((a, b) => new Date(b.time) - new Date(a.time));

                            sortedEventMessages.forEach(msg => {
                                // end of the messages
                                if (msg.message === endOfMessage) {
                                    intervalManager.stopAll();
                                    appState.progress.started = false;
                                    const durationLogs = document.getElementById('duration-logs');
                                    duration.textContent = '';
                                    durationLogs.textContent = '';
                                    return;
                                }
                                // compute the time from the first message
                                const messageTime = new Date(msg.time);
                                const elapsedSeconds = Math.floor((messageTime - startingTime) / 1000);
                                const timeText = elapsedSeconds > 0 ? `${elapsedSeconds}s` : startingTime.toLocaleTimeString();
                                
                                // Create row and route to appropriate table
                                const mask = parseInt(msg.section.split(':')[1] || '0');
                                const medicalValue1 = 1;    // events:1
                                const medicalValue2 = 2;    // events:2
                                const technicalValue = 4;  // events:4
                                
                                const isMedical = (mask & medicalValue1) !== 0 || (mask & medicalValue2) !== 0;
                                const isTechnical = (mask & technicalValue) !== 0;
                                
                                if (isMedical) {
                                    // Determine icon based on section
                                    const msgMask = parseInt(msg.section.split(':')[1] || '0');
                                    const msgIsTechnical = (msgMask & technicalValue) !== 0;
                                    
                                    let iconName = '';
                                    // Only show icon if message is NOT also displayed in Logs
                                    if (!msgIsTechnical) {
                                        if ((msgMask & 1) !== 0) {  // events:1
                                            iconName = 'new_label';  // Material icon for "New Label"
                                        } else if ((msgMask & 2) !== 0) {  // events:2
                                            iconName = 'label';  // Material icon for "Label"
                                        }
                                    }
                                    
                                    const row = ui.createTableRowWithIcon(iconName, msg.message, timeText);
                                    row.dataset.section = msg.section;
                                    activityTbody.appendChild(row);
                                }
                                if (isTechnical) {
                                    const row = ui.createTableRow([msg.message, timeText]);
                                    row.dataset.section = msg.section;
                                    logsTbody.appendChild(row);
                                }
                            });
                        }

                        // Handle transcript section (Transcript tab)
                        if (transcriptMessages.length > 0) {
                            const colors = CONSTANTS.SPEAKER_COLORS;

                            transcriptMessages.forEach(msg => {
                                if (msg.message === endOfMessage) {
                                    intervalManager.stopAll();
                                    appState.progress.started = false;
                                    return;
                                }

                                // Skip if we've already displayed this message
                                if (appState.transcript.displayedTimes.has(msg.time)) {
                                    return;
                                }

                                try {
                                    const discussionTurnArray = JSON.parse(msg.message);
                                    // Handle array of DiscussionTurn objects
                                    if (Array.isArray(discussionTurnArray)) {
                                        // Add all turns from this batch to the pending queue
                                        discussionTurnArray.forEach(discussionTurn => {
                                            // Assign color to new speakers
                                            if (!appState.transcript.speakerColors.has(discussionTurn.speaker)) {
                                                appState.transcript.speakerColors.set(discussionTurn.speaker, colors[appState.transcript.colorIndex % colors.length]);
                                                appState.transcript.colorIndex++;
                                            }

                                            appState.transcript.pendingTurns.push({
                                                speaker: discussionTurn.speaker,
                                                text: discussionTurn.text,
                                                messageTime: msg.time
                                            });
                                        });

                                        // Mark this message time as displayed
                                        appState.transcript.displayedTimes.add(msg.time);
                                    }
                                } catch (e) {
                                    console.warn('Failed to parse discussion turn:', msg.message);
                                }
                            });

                            // Update legend with all known speakers using utility
                            ui.updateLegend(appState.transcript.speakerColors);

                            // Start processing turns if not already processing
                            if (!appState.transcript.processingTurns && appState.transcript.pendingTurns.length > 0) {
                                processTurnQueue();
                            }
                        }
                    }
            } catch (err) {
                errorDiv.textContent = `Error: ${err.message}`;
            }

            // Set default content if tables are empty
            if (activityTbody.innerHTML === '') {
                activityTbody.innerHTML = '<tr><td colspan="3">...</td></tr>';
            }
            if (logsTbody.innerHTML === '') {
                logsTbody.innerHTML = '<tr><td colspan="2">...</td></tr>';
            }
            if (transcriptTbody.innerHTML === '') {
                transcriptTbody.innerHTML = '<tr><td>...</td></tr>';
            }
        }

        function processTurnQueue() {
            if (appState.transcript.pendingTurns.length === 0) {
                appState.transcript.processingTurns = false;
                return;
            }

            appState.transcript.processingTurns = true;
            const transcriptTbody = document.getElementById('transcript-table-body');

            // Remove "waiting..." row if it exists
            if (transcriptTbody.innerHTML.includes('waiting...')) {
                transcriptTbody.innerHTML = '';
            }

            // Get the first turn from the queue
            const turn = appState.transcript.pendingTurns.shift();

            // Check if the first row is from the same speaker
            const firstRow = transcriptTbody.firstChild;
            let shouldCombine = false;

            if (firstRow && firstRow.tagName === 'TR' && firstRow.dataset.speaker === turn.speaker) {
                shouldCombine = true;
            }

            if (shouldCombine) {
                // Append to existing cell with a line break
                const existingCell = firstRow.firstChild;
                existingCell.textContent += '\n' + turn.text;
                // Update the message time to the most recent
                firstRow.dataset.messageTime = turn.messageTime;
            } else {
                // Create new row at the top
                const textCell = document.createElement('td');
                textCell.textContent = turn.text;
                textCell.style.backgroundColor = appState.transcript.speakerColors.get(turn.speaker);
                textCell.style.padding = '8px';
                textCell.style.whiteSpace = 'pre-wrap';

                const row = document.createElement('tr');
                row.appendChild(textCell);
                row.dataset.messageTime = turn.messageTime;
                row.dataset.speaker = turn.speaker;

                // Insert at the top
                transcriptTbody.insertBefore(row, transcriptTbody.firstChild);
            }

            // Wait for next turn processing - but process immediately if session is ended or paused
            const delay = (appState.recording.ended || appState.recording.paused) ? 0 : CONSTANTS.REFRESH_INTERVALS.TURN_PROCESSING;
            setTimeout(() => {
                processTurnQueue();
            }, delay);
        }

        // Global variable to track feedback message timeout
        let feedbackMessageTimeout = null;

        function clearFeedbackMessage() {
            const messageSpan = document.getElementById('feedback-message');
            messageSpan.textContent = '';
            messageSpan.className = '';
            if (feedbackMessageTimeout) {
                clearTimeout(feedbackMessageTimeout);
                feedbackMessageTimeout = null;
            }
        }

        function showFeedbackMessage(text, className = '') {
            const messageSpan = document.getElementById('feedback-message');
            
            // Clear any existing timeout
            if (feedbackMessageTimeout) {
                clearTimeout(feedbackMessageTimeout);
            }
            
            messageSpan.textContent = text;
            messageSpan.className = className;
            
            // Set timeout to clear message after 5 seconds (unless it's a "Sending..." message)
            if (text !== 'Sending...') {
                feedbackMessageTimeout = setTimeout(clearFeedbackMessage, 5000);
            }
        }

        function submitFeedback() {
            const textarea = document.getElementById('feedback-textarea');
            const submitButton = document.getElementById('feedback-submit-button');
            const feedbackText = textarea.value.trim();
            
            // Clear previous message
            clearFeedbackMessage();
            
            if (!feedbackText) {
                showFeedbackMessage('Please enter some feedback before submitting.', 'error');
                return;
            }
            
            // Disable the submit button while processing
            submitButton.disabled = true;
            submitButton.textContent = 'Submitting...';
            showFeedbackMessage('Sending...');
            
            // Prepare the feedback data
            const formData = new FormData();
            formData.append('feedback', feedbackText);
            
            // Submit the feedback to the feedbackURL
            fetch('{{feedbackURL | safe}}', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (response.ok) {
                    textarea.value = '';
                    showFeedbackMessage('Thank you for your feedback!', 'success');
                } else {
                    // Try to get error message from response
                    return response.text().then(errorText => {
                        throw new Error(errorText || `Server error: ${response.status}`);
                    });
                }
            })
            .catch(error => {
                console.error('Error submitting feedback:', error);
                // Display the actual error message received from the server
                console.log(`error.message: ${error.message}`);
                const errorMessage = error.message || 'Unknown error occurred';
                console.log(`errorMessage: ${errorMessage}`);
                showFeedbackMessage(`Error: ${errorMessage}`, 'error');
            })
            .finally(() => {
                // Re-enable the submit button
                submitButton.disabled = false;
                submitButton.textContent = 'Submit';
            });
        }
    </script>
</body>
</html>